import { Injectable, OnDestroy } from '@angular/core';
import { HubConnectionState } from '@microsoft/signalr';
import { BehaviorSubject, combineLatest, firstValueFrom, Subject, Subscription } from 'rxjs';
import { map, tap } from 'rxjs/operators';
import { SyncStartGameStartedState, SyncStartGameState } from '../../game/game.models';
import { LocalStorageService, StorageKey } from '../local-storage.service';
import { LogService } from '../log.service';
import { HubState, NotificationService } from '../notification.service';
import { GameService } from '../../api/game.service';

export interface GameHubEvent<T> {
    gameId: string;
    eventType: GameHubEventType;
    data: T;
}

enum GameHubEventType {
    SyncStartGameStarting = "syncStartGameStarting",
    SyncStartStateChanged = "syncStartStateChanged"
}

@Injectable({ providedIn: 'root' })
export class GameHubService implements OnDestroy {
    private gameHubEventsSub?: Subscription;
    private manageJoinGameRequestSub?: Subscription;

    private _syncStartStateChanged$ = new Subject<SyncStartGameState>();
    private _syncStartGameStarted$ = new Subject<SyncStartGameStartedState>();
    private _manualRefresh$ = new Subject<void>();

    public syncStartStateChanged$ = this._syncStartStateChanged$.asObservable();
    public syncStartGameStarted$ = this._syncStartGameStarted$.asObservable();
    public joinGameRequest$ = new BehaviorSubject<string | null>(null);

    // TODO: someday, refactor core connection stuff into a the signalr service and create federated services for each channel type
    // constructor(private signalr: SignalrService) {
    //     this.signalr.gameHubEvents$.subscribe(ev => {
    //         switch (ev.data.eventType) {
    //             case GameHubEventType.PlayerReadyStateChanged:
    //                 this.handlePlayerReadyStateChanged(ev.data);
    //                 return;
    //             default:
    //                 return;
    //         }
    //     });
    // }

    constructor(
        private gameService: GameService,
        private localStorageService: LocalStorageService,
        private logger: LogService,
        private notificationService: NotificationService) {

        combineLatest([
            this._manualRefresh$,
            notificationService.state$
        ]).pipe(
            map(([_, hubServiceState]) => ({ hubServiceState })),
            tap(ctx => this.maybeJoinGames(ctx.hubServiceState))
        ).subscribe();

        this.gameHubEventsSub = notificationService.gameHubEvents$.subscribe(ev => {
            switch (ev.eventType) {
                case GameHubEventType.SyncStartStateChanged:
                    this._syncStartStateChanged$.next(ev.data as SyncStartGameState);
                    return;
                case GameHubEventType.SyncStartGameStarting:
                    this._syncStartGameStarted$.next(ev.data as SyncStartGameStartedState);
                    return;
                default:
                    return;
            }
        });
    }

    public joinGame(gameId: string) {
        if (!gameId) {
            this.logger.logError("Can't join a blank GameId.");
            return;
        }

        // push the game into our local storage list to join and let our pipeline know it has work to do
        const gamesJoined = this.loadGameHubConnections();
        if (gamesJoined.indexOf(gameId) < 0) {
            gamesJoined.push(gameId);
            this.localStorageService.add(StorageKey.WantsGameHubConnections, JSON.stringify(gamesJoined));
        }

        this._manualRefresh$.next();
    }

    public leaveGame(gameId: string) {
        if (this.notificationService.state$.getValue().connectionState === HubConnectionState.Connected)
            this.notificationService.sendMessage("LeaveChannel", gameId);

        this.removeFromPendingGameHubConnections(gameId);
    }

    private loadGameHubConnections(): string[] {
        return JSON.parse(this.localStorageService.get(StorageKey.WantsGameHubConnections) || '[]');
    }

    private async maybeJoinGames(hubState: HubState) {
        const gameIdsToJoin = this.loadGameHubConnections();
        if (hubState.connectionState === HubConnectionState.Connected && gameIdsToJoin.length) {
            for (let gameId of gameIdsToJoin) {
                // join the channel
                const game = await firstValueFrom(this.gameService.retrieve(gameId));

                if (game.requireSynchronizedStart) {
                    const state = await this.notificationService.sendMessage<SyncStartGameState>("JoinGame", gameId);
                    this._syncStartStateChanged$.next(state);
                }
            }
        }
    }

    private removeFromPendingGameHubConnections(gameId: string) {
        const gameIdsToJoin: string[] = this
            .loadGameHubConnections()
            .filter(g => g !== gameId);

        this.localStorageService.add(StorageKey.WantsGameHubConnections, JSON.stringify(gameIdsToJoin));
    }

    ngOnDestroy(): void {
        this.gameHubEventsSub?.unsubscribe();
        this.manageJoinGameRequestSub?.unsubscribe();
    }
}
